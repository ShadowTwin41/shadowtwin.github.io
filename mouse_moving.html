<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Radial reveal (single background.jpg) + Particles</title>
  <style>
    :root{
      --mouse-x: 50%;
      --mouse-y: 50%;
      --mask-size: 1%;    /* percent of viewport */
      --mask-feather: 6%; /* percent */
      --image-brightness: 1.15;
      --vignette-opacity: 0.35;
    }

    html,body{height:100%;margin:0}
    body{
      background:#000;
      color:#fff;
      font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      min-height:100vh;
      position:relative;
      overflow:hidden;
    }

    /* responsive image wrapper */
    .bg-wrap{
      position:fixed;
      inset:0;
      z-index:0;
      pointer-events:none;
      overflow:hidden;
    }

    /* single responsive image (full image shrinkable) */
    .bg-wrap img.bg-image{
      position:absolute;
      left:50%;
      top:50%;
      width:100%;
      height:100%;
      max-width:100%;
      max-height:100%;
      transform:translate(-50%,-50%);
      object-fit:contain; /* ensures full image visible */
      filter:brightness(var(--image-brightness));
      transition: width 220ms ease, height 220ms ease;
      will-change: mask-image, -webkit-mask-image;
      mask-image: radial-gradient(
        circle at var(--mouse-x) var(--mouse-y),
        rgba(0,0,0,1) 0%,
        rgba(0,0,0,1) var(--mask-size),
        rgba(0,0,0,0) calc(var(--mask-size) + var(--mask-feather))
      );
      -webkit-mask-image: radial-gradient(
        circle at var(--mouse-x) var(--mouse-y),
        rgba(0,0,0,1) 0%,
        rgba(0,0,0,1) var(--mask-size),
        rgba(0,0,0,0) calc(var(--mask-size) + var(--mask-feather))
      );
    }

    /* vignette overlay */
    .bg-wrap::after{
      content:'';
      position:absolute; inset:0;
      mix-blend-mode:multiply;
      background: radial-gradient(120% 120% at 50% 50%, rgba(0,0,0,0) 40%, rgba(0,0,0,var(--vignette-opacity)) 100%);
      pointer-events:none;
    }

    @media (prefers-reduced-motion: reduce){
      .bg-wrap img.bg-image { transition:none; }
    }

    main{ position:relative; z-index:6; padding:3.5rem; pointer-events:auto; }
    h1{ margin:0 0 .6rem; font-size:clamp(1.5rem, 3vw, 2.2rem) }
    p{ margin:0; opacity:0.92; max-width:60ch; line-height:1.5 }

    /* Particle canvas sits above the bg image but below main content */
    #particle-canvas {
      position: fixed;
      inset: 0;
      z-index:2;
      pointer-events: none;
      display:block;
    }
  </style>
</head>
<body>
  <!-- particle canvas -->
  <canvas id="particle-canvas" aria-hidden="true"></canvas>

  <!-- single responsive image -->
  <div class="bg-wrap" aria-hidden="true">
    <img class="bg-image" src="/imgs/background.jpg" alt="">
  </div>

  <main>
    <h1>Reveal the image with your mouse</h1>
    <p>Move to reveal. Click (or tap) to send a slow radial gradient wave from the click point.</p>
  </main>

  <script>
    // --------------------------- Mask + wave logic ---------------------------
    (function(){
      if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

      const bg = document.querySelector('.bg-image');
      if (!bg) return;

      let tx = innerWidth / 2, ty = innerHeight / 2;
      function toPercent(value, max){ return (value / max * 100).toFixed(4) + '%'; }

      function updatePos(clientX, clientY){
        tx = clientX; ty = clientY;
        bg.style.setProperty('--mouse-x', toPercent(tx, window.innerWidth));
        bg.style.setProperty('--mouse-y', toPercent(ty, window.innerHeight));
      }

      window.addEventListener('mousemove', (e)=> updatePos(e.clientX, e.clientY), {passive:true});
      window.addEventListener('touchstart', (e)=> {
        if (e.touches && e.touches.length) updatePos(e.touches[0].clientX, e.touches[0].clientY);
      }, {passive:true});
      window.addEventListener('touchmove', (e)=> {
        if (e.touches && e.touches.length) updatePos(e.touches[0].clientX, e.touches[0].clientY);
      }, {passive:true});

      window.addEventListener('resize', ()=> {
        bg.style.setProperty('--mouse-x', toPercent(tx, window.innerWidth));
        bg.style.setProperty('--mouse-y', toPercent(ty, window.innerHeight));
      }, {passive:true});

      function parsePercent(str, fallback=0){
        if (!str) return fallback;
        const m = String(str).trim().match(/^(-?[\d.]+)/);
        return m ? parseFloat(m[1]) : fallback;
      }
      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

      let waveRAF = null;
      let waveStart = 0;
      const DEFAULTS = {
        startSize: 0.8,
        startFeather: 6,
        peakSize: 65,
        peakFeather: 28,
        startVignette: 0.35,
        peakVignette: 0.05,
        duration: 2000
      };

      bg.style.setProperty('--mask-size', DEFAULTS.startSize + '%');
      bg.style.setProperty('--mask-feather', DEFAULTS.startFeather + '%');
      bg.style.setProperty('--vignette-opacity', DEFAULTS.startVignette);

      function animateWave(options = {}) {
        const {
          startSize = DEFAULTS.startSize,
          startFeather = DEFAULTS.startFeather,
          peakSize = DEFAULTS.peakSize,
          peakFeather = DEFAULTS.peakFeather,
          startVignette = DEFAULTS.startVignette,
          peakVignette = DEFAULTS.peakVignette,
          duration = DEFAULTS.duration
        } = options;

        let currentSize = parsePercent(getComputedStyle(bg).getPropertyValue('--mask-size'), startSize);
        let currentFeather = parsePercent(getComputedStyle(bg).getPropertyValue('--mask-feather'), startFeather);
        let currentVig = parseFloat(getComputedStyle(bg).getPropertyValue('--vignette-opacity')) || startVignette;

        if (waveRAF) cancelAnimationFrame(waveRAF);
        waveStart = performance.now();

        function frame(now) {
          const elapsed = now - waveStart;
          let t = Math.min(1, elapsed / duration);
          const ease = easeOutCubic(t);

          const size = currentSize + (peakSize - currentSize) * ease;
          const feather = currentFeather + (peakFeather - currentFeather) * ease;
          const vig = currentVig + (peakVignette - currentVig) * ease;

          bg.style.setProperty('--mask-size', size.toFixed(4) + '%');
          bg.style.setProperty('--mask-feather', feather.toFixed(4) + '%');
          bg.style.setProperty('--vignette-opacity', vig.toFixed(4));

          if (t < 1) {
            waveRAF = requestAnimationFrame(frame);
          } else {
            const settleStart = performance.now();
            const settleDuration = 700;
            const settleFrom = { size, feather, vig };
            function settle(now2) {
              const elapsed2 = now2 - settleStart;
              const tt = Math.min(1, elapsed2 / settleDuration);
              const e2 = 1 - Math.pow(1 - tt, 2);
              const sSize = settleFrom.size + (startSize - settleFrom.size) * e2;
              const sFeather = settleFrom.feather + (startFeather - settleFrom.feather) * e2;
              const sVig = settleFrom.vig + (startVignette - settleFrom.vig) * e2;
              bg.style.setProperty('--mask-size', sSize.toFixed(4) + '%');
              bg.style.setProperty('--mask-feather', sFeather.toFixed(4) + '%');
              bg.style.setProperty('--vignette-opacity', sVig.toFixed(4));

              if (tt < 1) waveRAF = requestAnimationFrame(settle);
              else waveRAF = null;
            }
            waveRAF = requestAnimationFrame(settle);
          }
        }

        waveRAF = requestAnimationFrame(frame);
      }

      function clickWave(clientX, clientY){
        updatePos(clientX, clientY);
        animateWave({
          startSize: 0.8,
          startFeather: 6,
          peakSize: 65,
          peakFeather: 28,
          startVignette: 0.35,
          peakVignette: 0.05,
          duration: 4000
        });
      }

      window.addEventListener('click', (e)=> {
        clickWave(e.clientX, e.clientY);
      }, {passive:true});

      window.addEventListener('touchend', (e)=> {
        const t = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]);
        if (t) clickWave(t.clientX, t.clientY);
      }, {passive:true});
    })();

    // --------------------------- Particles ---------------------------
    (function(){
      const canvas = document.getElementById('particle-canvas');
      const ctx = canvas.getContext('2d');
      const bg = document.querySelector('.bg-image');

      let DPR = Math.max(1, window.devicePixelRatio || 1);

      class Particle {
        constructor(w, h) {
          this.x = Math.random() * w;
          this.y = Math.random() * h;
          this.vx = (Math.random() - 0.5) * 2;
          this.vy = (Math.random() - 0.5) * 2;
          this.size = Math.random() * 3 + 2;
        }
        update(w, h) {
          this.x += this.vx;
          this.y += this.vy;
          if (this.x > w) { this.x = w; this.vx *= -1; }
          if (this.x < 0) { this.x = 0; this.vx *= -1; }
          if (this.y > h) { this.y = h; this.vy *= -1; }
          if (this.y < 0) { this.y = 0; this.vy *= -1; }
        }
        draw(ctx, alpha) {
          if (alpha <= 0) return;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0,200,255,${(0.85 * alpha).toFixed(3)})`;
          ctx.fill();
        }
      }

      let particles = [];
      const numParticles = 50;
      const connectDistance = 150;

      function setCanvasSize() {
        DPR = Math.max(1, window.devicePixelRatio || 1);
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        canvas.width = Math.floor(w * DPR);
        canvas.height = Math.floor(h * DPR);
        ctx.setTransform(1,0,0,1,0,0);
        ctx.scale(DPR, DPR);
      }

      function initParticles() {
        setCanvasSize();
        particles = [];
        for (let i = 0; i < numParticles; i++) {
          particles.push(new Particle(window.innerWidth, window.innerHeight));
        }
      }

      function getMousePosFromCSS() {
        const mx = getComputedStyle(bg).getPropertyValue('--mouse-x') || '50%';
        const my = getComputedStyle(bg).getPropertyValue('--mouse-y') || '50%';
        const mxN = parseFloat(mx) / 100 * window.innerWidth;
        const myN = parseFloat(my) / 100 * window.innerHeight;
        return { x: mxN, y: myN };
      }

      function getMaskParams() {
        const maskSizeRaw = getComputedStyle(bg).getPropertyValue('--mask-size') || '1%';
        const maskFeatherRaw = getComputedStyle(bg).getPropertyValue('--mask-feather') || '6%';
        const maskSize = parseFloat(maskSizeRaw);
        const maskFeather = parseFloat(maskFeatherRaw);
        return { maskSize, maskFeather };
      }

      function maskPercentToPx(pct) {
        const ref = Math.max(window.innerWidth, window.innerHeight);
        return (pct / 100) * ref;
      }

      function computeMaskAlphaAtPoint(px, py, maskRadiusPx, maskFeatherPx, centerX, centerY) {
        const dx = px - centerX;
        const dy = py - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist <= maskRadiusPx) return 1;
        if (maskFeatherPx <= 0) return 0;
        if (dist <= maskRadiusPx + maskFeatherPx) {
          return 1 - (dist - maskRadiusPx) / maskFeatherPx;
        }
        return 0;
      }

      function animateParticles() {
        ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);

        const { x: mouseX, y: mouseY } = getMousePosFromCSS();
        const { maskSize, maskFeather } = getMaskParams();
        const radiusPx = maskPercentToPx(maskSize);
        const featherPx = maskPercentToPx(maskFeather);

        for (let p of particles) {
          p.update(window.innerWidth, window.innerHeight);
          const alpha = computeMaskAlphaAtPoint(p.x, p.y, radiusPx, featherPx, mouseX, mouseY);
          p.draw(ctx, alpha);
        }

        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const a = particles[i];
            const b = particles[j];
            const dx = a.x - b.x;
            const dy = a.y - b.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < connectDistance) {
              const midX = (a.x + b.x) / 2;
              const midY = (a.y + b.y) / 2;
              const maskAlpha = computeMaskAlphaAtPoint(midX, midY, radiusPx, featherPx, mouseX, mouseY);
              if (maskAlpha <= 0) continue;
              const baseAlpha = 1 - dist / connectDistance;
              ctx.beginPath();
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
              ctx.strokeStyle = `rgba(0,150,255,${(baseAlpha * maskAlpha * 0.95).toFixed(3)})`;
              ctx.lineWidth = 1.5;
              ctx.stroke();
            }
          }
        }

        requestAnimationFrame(animateParticles);
      }

      initParticles();
      animateParticles();

      let resizeDebounce = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeDebounce);
        resizeDebounce = setTimeout(() => {
          initParticles();
        }, 120);
      }, {passive:true});
    })();

    // -------------------- Shrink image proportionally on small screens --------------------
    (function(){
      const bg = document.querySelector('.bg-image');
      const SMALL_WIDTH = 800; // px
      const SHRINK_TO = 0.9;   // 90% of full size

      function updateSize(){
        const scale = (window.innerWidth <= SMALL_WIDTH) ? SHRINK_TO : 1;
        bg.style.width = (scale*100) + '%';
        bg.style.height = (scale*100) + '%';
      }

      updateSize();
      window.addEventListener('resize', updateSize, {passive:true});
    })();
  </script>
</body>
</html>
